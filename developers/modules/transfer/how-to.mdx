---
title: "How-to"
---

This guide covers how to integrate the Neutron Transfer module into smart contracts for cross-chain token transfers.

## Sending IBC Transfers from CosmWasm Contracts

To send IBC transfers from a smart contract:

```rust
use cosmwasm_std::{
    Coin, CosmosMsg, DepsMut, Env, MessageInfo, Response, StdResult,
    to_binary, Binary, Timestamp, Uint128, Uint64,
};
use neutron_sdk::bindings::{msg::NeutronMsg, types::Height};
// Note: Fee type structure depends on neutron.feerefunder.Fee implementation

// Assuming ExecuteMsg enum has an IbcTransfer variant
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ExecuteMsg {
    // Other messages...
    IbcTransfer {
        channel_id: String,
        receiver: String,
        amount: Coin,
        timeout_timestamp: Option<u64>,
    },
}

fn execute_ibc_transfer(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    channel_id: String,
    receiver: String,
    amount: Coin,
    timeout_timestamp: Option<u64>,
) -> StdResult<Response> {
    // Create the IBC transfer message
    let timeout_timestamp = timeout_timestamp.unwrap_or_else(|| 
        env.block.time.plus_seconds(3600).nanos() // Default 1 hour timeout
    );
    
    // Create the fee structure (refer to feerefunder module for fee requirements)
    let fee = /* Fee structure as defined by neutron.feerefunder.Fee */;
    
    // Create the transfer message
    let transfer_msg = NeutronMsg::IbcTransfer {
        source_port: "transfer".to_string(),
        source_channel: channel_id.clone(),
        token: amount.clone(),
        sender: env.contract.address.to_string(),
        receiver,
        timeout_height: Height {
            revision_number: 0,
            revision_height: 0,
        },
        timeout_timestamp,
        memo: format!("Transfer from contract {}", env.contract.address),
        fee,
    };
    
    // Create the cosmos message
    let cosmos_msg = CosmosMsg::Custom(transfer_msg);
    
    // Return the response with the message
    Ok(Response::new()
        .add_message(cosmos_msg)
        .add_attribute("action", "ibc_transfer")
        .add_attribute("sender", env.contract.address)
        .add_attribute("channel", channel_id)
        .add_attribute("amount", amount.amount.to_string())
        .add_attribute("denom", amount.denom))
}

## Handling IBC Transfer Results in Contracts

The Transfer module uses Sudo callbacks to inform contracts about the result of their IBC transfers. The specific callback message format is defined by the Contract Manager module. To handle these callbacks, implement the Sudo entry point in your contract:

```rust
use cosmwasm_std::{
    to_binary, DepsMut, Env, Response, StdResult, Binary, Empty
};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

// Note: Actual SudoMsg structure depends on contractmanager implementation
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum SudoMsg {
    // Callback message types are defined by the contractmanager module
    // Refer to contractmanager documentation for exact format
}

pub fn sudo(deps: DepsMut, env: Env, msg: SudoMsg) -> StdResult<Response> {
    // Handle different callback types based on contractmanager implementation
    // The transfer module calls contractmanager.PrepareSudoCallbackMessage()
    // which defines the actual message format and request_id structure
    
    // Implementation depends on the specific callback format
    // provided by the contractmanager module
    
    Ok(Response::new()
        .add_attribute("action", "sudo_callback_processed"))
}

## Tracking IBC Transfers in Contracts

To correlate IBC transfer requests with their responses in your contract, use the response information provided by the Transfer module:

1. **When sending an IBC transfer**, store the transfer details using the response information:

```rust
// Define a struct to store transfer information
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct TransferInfo {
    pub channel: String,
    pub sequence: u64,
    pub recipient: String,
    pub amount: Coin,
    pub timestamp: u64,
    // Add any other information you need to track
}

// Use this map to store transfer information
const TRANSFERS: Map<(String, u64), TransferInfo> = Map::new("transfers");

// In your execute function, after getting the response:
fn execute_ibc_transfer(/* params */) -> StdResult<Response> {
    // ... existing code to create and send the IBC transfer
    
    // Extract sequence and channel from the MsgTransferResponse
    // (Response structure: sequence_id: u64, channel: String)
    let res: MsgTransferResponse = // ... parse the response
    
    // Store the transfer information
    let transfer_info = TransferInfo {
        channel: res.channel.clone(),
        sequence: res.sequence_id,
        recipient: receiver.clone(),
        amount: amount.clone(),
        timestamp: env.block.time.nanos(),
    };
    
    TRANSFERS.save(deps.storage, (res.channel, res.sequence_id), &transfer_info)?;
    
    // Return response
    Ok(Response::new()
        // ... existing attributes
        .add_attribute("sequence_id", res.sequence_id.to_string()))
}
```

2. **When handling Sudo callbacks**, correlate with stored transfers based on the callback format defined by the contractmanager module:

```rust
pub fn sudo(deps: DepsMut, env: Env, msg: SudoMsg) -> StdResult<Response> {
    // Parse callback information according to contractmanager implementation
    // Extract channel and sequence information from the callback
    // (exact format depends on contractmanager.PrepareSudoCallbackMessage)
    
    // Use the extracted information to find your stored transfer:
    // let transfer_info = TRANSFERS.may_load(deps.storage, (channel, sequence))?;
    
    // Process the callback with the original transfer details
    // Remove the transfer from storage once processed if needed
    
    Ok(Response::new()
        .add_attribute("action", "process_callback"))
}
```

## IBC Transfer Fees

When sending IBC transfers from contracts, you need to specify fees for packet relaying as defined by the `neutron.feerefunder.Fee` structure. The exact fee requirements and structure are defined by the Fee Refunder module.

```rust
// Fee structure is defined by neutron.feerefunder.Fee
// Refer to the feerefunder module documentation for:
// - Fee structure definition
// - Balance requirements
// - Fee distribution mechanism
let fee = /* Fee structure as defined by feerefunder module */;
```

The Transfer module validates fees for contracts only (as seen in the `Validate(isContract bool)` method). Non-contract senders do not require fee validation.

## Error Handling

When receiving callbacks via Sudo, be aware that the Transfer module:

1. Calls `sudoKeeper.Sudo(ctx, senderAddress, msg)` to deliver the callback
2. Logs any errors from the Sudo call but continues processing regardless
3. The specific error handling, gas limits, and middleware behavior are managed by the Contract Manager module

Refer to the Contract Manager module documentation for details on Sudo call processing.

## Best Practices

1. **Store minimal information**: When saving transfer details, store only what you need to correlate with callbacks
2. **Set appropriate timeouts**: Choose timeouts that make sense for your application (e.g., 1 hour for fast operations, longer for complex flows)
3. **Use meaningful memos**: Include transaction purposes or identifiers in memos to help with debugging and tracking
4. **Handle all callback types**: Implement proper handling for all callback types defined by the contractmanager module
5. **Clean up after processing**: Remove stored transfer information once you've processed the result
6. **Consider retry logic**: Implement retry mechanisms for failed or timed-out transfers if appropriate for your application 